---
title: projects/Morse 2.0 Short Message Encryption
description: Simple encryption algorithm implemented in Java/final project for Computer Security course
layout: project
show_github_link: false
---

My final project for a foundational computer security course I took in spring of 2022, the Morse 2.0 Short Message Encryption algorithm is my attempt to create a simple yet effective method of encrypting short text messages. The code and project report can be found on GitHub [here](https://github.com/liamharder/morse2encryption), but a brief summary of the algorithm is provided here for reference.

Every encryption algorithm I'm aware of always produce the same outputs for any given set of inputs. If you enter in the same message with the same key, you get the same ciphertext at the end of the process, meaning that if you send the same message more than once it's immediately obvious to any would-be eavesdroppers. The generally agreed-upon solution in modern cryptography is to never reuse keys for this exact reason, but what if we could design an algorithm that produced multiple potential outputs for the same input - while still ensuring that those outputs can all still be decrypted back into the original message?

Morse 2.0 Short Message Encryprion, or M2SME for short, is my attempt to answer that question. M2SME can generate a wide range of possible outputs from the same input using a key only a few bytes long, while remaining computationally simple enough to perform entirely by hand if needed. Encryption using M2SME is a 2-step process: reduce the number of distinct characters used in the message, in this case by translating it into a text-based version of Morse code, and then assign unique lists of characters to each remaining character type in the original message. 

For instance, in a message comprised of dots and dashes (as is the case with Morse code), we could assign the letters _a, b, c_ to dots and the letters _d, e, f_ to dashes. After translating our message to Morse, we then go character by character substituting those letters in for our dots and dashes. Every dot is randomly replaced with a, b, or c, and every dash is likewise replaced with d, e, or f. This process can produce an incredible amount of possible outputs (or ciphertexts, to use the technical term) for the same message, which all still decode to the same original message simply by swapping the dots and dashes back in provided the recipient has the same two lists.

In practice, we also find we need a third type of character, one that I have dubbed "slash", to denote the end of one Morse letter and the start of the next. In proper Morse code being sent over a phone line, this is accomplished with a longer than usual delay between each letter. We can't exactly "pause" text, however, so the slash was introduced to serve that purpose. The end result is that we need three lists of characters in our key, one each for dots, dashes, and slashes.

At the end of the day, however, the primary concern of any encryption algorithm is how hard it is to crack. So, how secure is M2SME? The honest answer is that I don't entirely know. I'm not educated enough on modern cryptography to say for sure what vulnerabilities it may or may not have, but my general inclination is that I most likely did _not_ create a method of encryption on par with industry standard algorithms as an undergraduate project. Still, I could see M2SME having some use in an ARG or some other variety of digital easter egg hunt, but I certainly wouldn't rely on it to protect national secrets or anything similar.